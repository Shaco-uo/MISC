[FUNCTION f_set_store]
room.events +r_store_system
room.tag.store_sign=<uid>
name=<room.name>
tag.max_skins=<def.store_skin_amt>
tag.skins_used=3
tag.skin_1=c_store_vendor_m,Human Male,colors_skin,"Can equip items"
tag.skin_2=c_store_vendor_f,Human Female,colors_skin,"Can equip items"
tag.skin_3=c_slime,Frost Slime,0481,"Cold & Slippery"
more2h=<def.store_sell_max>				// set max items

serv.newitem=i_backpack,1,<uid>   			// when vendor human is deleted his gear goes here
tag.recycle_pack=<new>
new.contp=20,100
new.attr |= attr_move_never

local.x=60	
for 1 <room.tag0.max_vendors>          		// create 2-4 vendor storage packs
serv.newitem=i_backpack,1,<uid>				// store vendor packs in sign
tag.vendor_pack_<local._for>=<new>			// store vendor pack uid on sign
new.contp=<local.x>,100						// vendor pack location in layer store
new.attr |= attr_move_never
new.color=<local.x>	                		// any color will do
new.tag.skin_current=<R1,2>	        		// 1st use, human vendor (m/f)
local.x += 20
endfor
dispid=0bd3
nudgeup 3
sayu <name> Set!

[FUNCTION _store_set_owner]		//	_store_set_owner <sign_uid>
if !(<argo> && <argo.isplayer>)
	src.sysmessage @31,,1 Invalid Target.
	return 1
elif !<isempty <argo.account.tag.store>> && <argo.account.tag.store>!=<args>
	src.sysmessage @,,1 <argo.name> already has a store.
	return 1
endif
f_store_set_owner <args>,<argo>


[FUNCTION f_store_set_owner]  // f_store_set_owner <sign_uid>,<player_uid>
ref1=<argv[0]>	// store_sign
if !<isempty <ref1.tag.store_owner>>
	local.p=<ref1.p>
	ref1.remove
	serv.newitem=i_store_sign
	new.p=<local.p>
	ref1=<new>
endif
ref2=<argv[1]>  // player
ref2.account.tag.store=<ref1>
ref2.sysmessage @52,,1 You are now the owner of <ref1.name>.
ref1.tag.store_owner=<ref2>
ref1.tag.builton=<serv.rtime>
ref1.color=0
ref1.resendtooltip 1,0


[FUNCTION f_store_total_items]
ref1=<args>	// store sign
for 1 <ref1.room.tag0.max_vendors>
if !<isempty <ref1.tag.vendor_pack_<local._for>>>
	ref2=<tag.vendor_pack_<local._for>>
	local.total += <ref2.rescount>
endif
endfor
return <local.total>

[FUNCTION f_remove_vendor]	// f_remove_vendor <vendor #>,<sign>
ref1=<argv[1]>	// store_sign
if !<isempty <ref1.tag.vendor_<argv[0]>>>
	ref2=<ref1.tag.vendor_<argv[0]>>
	ref2.remove
endif

[FUNCTION f_remove_all_vendors]	// serv.f_remove_all_vendors <sign>
ref1=<args>	// store_sign
for 1 4
if !<isempty <ref1.tag.vendor_<local._for>>>
	ref2=<ref1.tag.vendor_<local._for>>
	ref2.remove
endif
endfor

[FUNCTION f_store_sell_item]
ref1=<argo>
ref2=<getargv 0 <src.ctag.vendor>> 	// sign
ref3=<getargv 1 <src.ctag.vendor>> 	// pack
local.v=<getargv 2 <src.ctag.vendor>> 	// pack #

src.dialogclose d_store_sell
if !(<ref1.isvalid> && <ref1.isitem>)
	src.sysmessage @31,,1 Invalid Target.
	ref3.dialog d_store_sell
	return 1
endif
if <ref1.topobj>!=<src> || <ref1.isinbank>
	src.sysmessage @,,1 <ref1.name> is not in your backpack.
	ref3.dialog d_store_sell
	return 1
endif
if <ref1.attr>&04 || <ref1.isevent.e_soulbound> || <ref1.istevent.e_soulbound> || <ref1.isevent.t_remove_timer> || <ref1.istevent.t_remove_timer>
	src.sysmessage @,,1 You cannot sell <ref1.name>.
	ref3.dialog d_store_sell
	return 1
endif
if <ref1.baseid>==i_gold || <ref1.baseid>==i_gold_check
	src.sysmessage @,,1 You cannot sell <ref1.name>.
	ref3.dialog d_store_sell
	return 1
endif
if <ref1.type>==t_container
	if <ref1.rescount>==0
		src.sysmessage @31,,1 You cannot sell empty containers.
		ref3.dialog d_store_sell
		return 1
	elif <ref1.rescount> > <def.store_container_max>
		src.sysmessage @31,,1 <ref1.name> has too many items inside. Max <def.store_container_max>.
		ref3.dialog d_store_sell
		return 1
	endif
endif
if <ref1.isweapon> || <ref1.isarmor>
	if <ref1.more1l>!=<ref1.more1h>
		src.sysmessage @,,1 <ref1.name> must be full repaired before selling.
		ref3.dialog d_store_sell
		return 1
	endif
endif
// ************************
for 1 <ref2.dmore2h>
if !<isempty <src.ctag.store_option>> 
	if <src.ctag.store_option> == <local._for>
		ref1.attr |= 010
		ref1.cont=<ref3>
		if <ref1.maxamount> 
			if <ref1.maxamount>!=<serv.ItemsMaxAmount>
				ref1.tag.old_maxamount=<ref1.maxamount>
			endif
			ref1.maxamount=<ref1.amount>
		endif
		ref3.tag.item_<local._for> = <ref1>
		ref3.tag.item_<local._for>_price = <def.store_default_price>	//<ref1.value>
		ref4=<tag.vendor_<local.v>>	// vendor #
		if <ref4.isvalid>
			ref4.resendtooltip 1,0
		endif
		src.sysmessage @52,,1 <ref1.name> has been added to store vendor <local.v> list.
	endif
endif
endfor
src.ctag.store_option=
ref3.dialog d_store_sell
return 1


[FUNCTION f_add_vendor] // usage: 	src.f_add_vendor 1,<uid>	// <vendor #>,<sign>
local.v=<argv[0]>	// vendor # (1-4)
ref1=<argv[1]>		// sign uid


if !<isempty <ref1.tag.vendor_<local.v>>>
	ref2=<ref1.tag.vendor_<local.v>>
	ref2.remove	// remove previous vendor npc
endif

ref3=<ref1.tag.vendor_pack_<local.v>>	// store pack #
args=<ref1.tag.skin_<ref3.tag0.skin_current>>
// tag.skin_1=c_store_vendor_m,Human Male,colors_skin,"Can be dressed"
serv.newnpc <argv[0]>
ref2=<new>
ref1.tag.vendor_<local.v>=<ref2>	// store vendor uid in sign
ref1.tag0.vendors += 1

ref2.p=<ref1.room.p>
ref2.home=<ref1.room.p>
ref2.homedist=0
ref2.color=<argv[2]>
ref2.str = 100
ref2.maxhits = 100
ref2.taming = 0	// to avoid "tame" contextmenu
ref2.flags |= 01	// invul
ref2.canmask |= mt_nonmover
ref2.events=+e_store_vendor
ref2.speech=+spk_store_vendor
if <ref2.baseid>==c_store_vendor_m
	ref2.name=#names_humanmale
	ref2.title=<ref1.name>
elif <ref2.baseid>==c_store_vendor_f
	ref2.name=#names_humanfemale
	ref2.title=<ref1.name>
else
	ref2.name=<argv[1]>
endif

ref2.tag.vendor_pack=<ref3>		// store pack uid in vendor
ref2.tag.store_sign=<ref1>			// store sign uid in vendor
ref2.tag.pack=<local.v>


if <ref1.room.tag0.max_vendors>==2
	if <local.v>==1		// vendor p	// FIXME: adjust locations 
		ref2.move nw 1
	elif <local.v>==2
		ref2.move sw 1
		ref2.move s 1
	endif
elif <ref1.room.tag0.max_vendors>==4
	if <local.v>==1		// vendor p
		ref2.move n 2
	elif <local.v>==2
		ref2.move e 3
		ref2.move s 1
	elif <local.v>==3
		ref2.move e 3
		ref2.move n 2
	elif <local.v>==4
		ref2.move w 3
		ref2.move s 1
	endif
endif

[FUNCTION f_store_vendor_dress]
ref1=<args>	// vendor
ref2=<argo>	// item
if !<ref2.isvalid>
	return 1
elif <ref2.topobj>!=<src> || <ref2.isinbank>
	sysmessage @,,1 You can't reach <ref2.name>.
	return 1
elif <ref2.attr>&04 || <ref2.isevent.e_soulbound> || <ref2.istevent.e_soulbound> || <ref2.isevent.t_remove_timer> || <ref2.istevent.t_remove_timer>
	sysmessage @,,1 Invalid Target.
	return 1
elif !(<ref2.isweapon> || <ref2.isarmor>)
	sysmessage @,,1 Invalid Target.
	return 1
elif <ref1.findlayer.<ref2.layer>.isvalid>
	src.sysmessage @,,1 <ref1.name> already has an item equipped in that slot.
	return 1
elif <ref2.isweapon> && <ref2.layer>==2 && <ref1.findlayer.1.isvalid>
	src.sysmessage @,,1 <ref1.name> already has a weapon equipped in slot 1.
	return 1
else
	ref2.events=+t_store_vendor_gear
	ref2.cont=<ref1>
endif
src.targetf f_store_vendor_dress <ref1>

[FUNCTION f_store_vendor_move]
ref1=<args>	// vendor uid
ref2=<src.account.tag.store>	// sign
if <src.isgm>
	ref2=<ref1.tag.store_sign>	// sign
endif
if <argo>
	sysmessage @,,1 Invalid Target.
	return 1
endif
if <targp>
	local.old_p=<ref1.p>
	ref1.go <targp>
	if !<ref1.room> || <ref1.room.uid>!=<ref2.room.uid>
		sysmessage @,,1 Invalid Target.
		ref1.go <local.old_p>
	endif
endif
return 1

[FUNCTION f_store_sign_move]
ref1=<args>	// sign uid
ref2=<src.account.tag.store>	// sign
if <src.isgm>
	ref2=<ref1>	// sign
endif
if <argo>
	sysmessage @,,1 Invalid Target.
	return 1
endif
if <targp>
	local.old_p=<ref1.p>
	ref1.p <targp>
	if !<ref1.room> || <ref1.room.uid>!=<ref2.room.uid>
		sysmessage @,,1 Invalid Target.
		ref1.p <local.old_p>
	endif
endif
ref1.dialog d_store_sign
return 1


[FUNCTION f_spawn_all_vendors]	// f_spawn_all_vendors <sign>
ref1=<args>	// store_sign
for 1 4
if !<isempty <ref1.tag.vendor_pack_<local._for>>>
	serv.f_add_vendor <local._for>,<ref1>
endif
endfor


[FUNCTION f_is_store_owner]	// <f_is_store_owner <sign>,>
ref1=<argv[0]>	// sign uid
ref2=<argv[1]>	// player uid
if !<isempty <ref2.account.tag.store>> && <ref2.account.tag.store>==<ref1>
	return 1
endif


[FUNCTION is_store_owner]
ref1=<args>
if <isempty <ref1.account.tag.store>> || <isempty <tag.store_owner>>
	return 0
else
	ref2=<tag.store_owner>
	if !(strcmpi(<ref2.account>,<ref1.account>))
		return 1
	else
		return 0
	endif
endif

[FUNCTION f_rename_vendor_chest]
ref1=<src.ctag.store_sign>
src.ctag.store_sign=
if (<isempty <args>>) || (<isnum <args>>) || (<eval strlen(<args>)> < 4) || strmatch(*<asc [[]>*,<asc <args>>) || strmatch(*<asc ]>*,<asc <args>>) || strmatch(*<asc [(]>*,<asc <args>>) || strmatch(*<asc ->*,<asc <args>>) || strmatch(*<asc [}`>?´;:^%$*¨!<#._~|=+&/æ{]>*,<asc <args>>) || strmatch(*<asc @>*,<asc <args>>)
	src.sysmessage @026,,1 Invalid Name.
elif <eval strlen(<args>)> > 26
	src.sysmessage @026,,1 Invalid Name (26 characters max).
else
	ref1.name=<args>
	src.sysmessage @,,1 Store renamed to <args>.
endif
if <ref1.distance> < 4
	ref1.dclick
endif

[FUNCTION f_vendor_saveonbag]   // fixme send backpack to sign storage instead
ref1=<argv[0]> // vendor
ref2=<argv[1]> // player
ref1.undress
serv.newitem=i_backpack,1,<ref2.findlayer.29>
new.contp=30,30
ref3=<new>
forcont <ref1.findlayer.21> 5
cont=<ref3>
endfor

[FUNCTION f_show_myitems]
for 1 24
   if <local._for>!=21 && <local._for>!=16 && <local._for>!=11
      if <src.findlayer.<local._for>.isvalid>
         ref1=<src.findlayer.<local._for>>
         serv.log layer <local._for> has <ref1.name>
      endif
   endif
endfor

[FUNCTION store_lockdown]
if !(<argo.isvalid> && <argo.isitem>)
	src.sysmessage @,,1 Invalid target.
	return 1
endif
if <argo.room>==0 || <argo.type>==t_container || <argo.isevent.ei_house_component> || <argo.type>==t_ethereal_mount
	src.sysmessage @,,1 You cannot lock that down.
	return 1
endif
if <argo.isevent.t_house_addon> || <argo.istevent.t_remove_timer> || <argo.isevent.t_remove_timer> || <argo.tag0.enchant_timer>
	src.sysmessage @,,1 Invalid target.
	return 1
endif
if <argo.isevent.t_store_lockdown>
	argo.message @,,1 Already Locked
	return 1
endif
argo.tag.old_attr=<argo.attr>
argo.attr = 010
argo.timer = -1
argo.events +t_store_lockdown
argo.room.tag0.lockdowns += 1
argo.message @,,1 Locked Down
argo.resendtooltip 1,0
return 1

[FUNCTION store_secure]
if !<argo.isvalid> || <argo.room>==0 || <isempty <argo.room.tag.store_sign>> || <argo.room.tag.store_sign>!=<account.tag.store>
	sysmessage @,,1 Invalid target.
	return 1
endif
if <argo.isevent.ei_house_component> || <argo.isevent.t_house_addon>
  sysmessage @,,1 You cannot secure that.
  return 1
endif
if <argo.type> != t_container
	src.sysmessage @,,1 You cannot secure that, try using Lock instead.
	return 1
endif
if <argo.isevent.t_store_secure>
	argo.message @,,1 Already Secured
	return 1
endif
argo.tag.old_attr=<argo.attr>
argo.attr = 010
argo.timer = -1
argo.events +t_store_secure
argo.room.tag0.secure += 1
argo.message @,,1 Secured

[FUNCTION store_release]
if !<argo.isvalid> || <argo.room>==0 || <isempty <argo.room.tag.store_sign>> || <argo.room.tag.store_sign>!=<account.tag.store>
	sysmessage @,,1 Invalid target.
	return 1
endif
if !(<argo.isevent.t_store_secure> || <argo.isevent.t_store_lockdown>)
	sysmessage @,,1 <argo.name> is not locked.
	return 1
endif
if <argo.isevent.t_store_secure>
	argo.events -t_store_secure
	argo.room.tag0.lockdowns -= 1
	argo.message @,,1 Unlocked
	argo.attr=<argo.tag0.old_attr>
	argo.tag.old_attr=
	argo.tag.access=
	argo.resendtooltip 1,0
	argo.update
	return 1
endif
if (<argo.isevent.t_store_lockdown>)
	argo.events -t_store_lockdown
	argo.room.tag0.secure -= 1
	argo.message @,,1 Unlocked
	argo.attr=<argo.tag0.old_attr>
	argo.tag.old_attr=
	argo.resendtooltip 1,0
	argo.update
	return 1
endif

[FUNCTION f_change_signs]	// f_change_signs 110,184
local.x=<argv[0]>
local.y=<argv[1]>
local.sign=2979
for 1 70
	if <local.y> > 300
		local.y=<argv[1]>
		local.x += 30
	endif
	buttontileart <local.x> <local.y> 07588 07588 1 0 <local.sign> <local.sign> 0 -10 -5
	local.sign +=2
	local._for +=1
	local.y += 25
	if <dlocal.sign> == 3087
		local.sign = 3139
	elif <dlocal.sign> > 3139
		return 
	endif
endfor

[FUNCTION f_change_signs2]
local.x=<argv[0]>
local.y=<argv[1]>
local.sign=2980
for 1 70
	if <local.y> > 300
		local.y=<argv[1]>
		local.x += 30
	endif
	buttontileart <local.x> <local.y> 07588 07588 1 0 <local.sign> <local.sign> 0 -10 -5
	local.sign +=2
	local._for +=1
	local.y += 25
	if <dlocal.sign> == 3088
		local.sign = 3140
	elif <dlocal.sign> > 3140
		return 
	endif
endfor

[EOF]